# System-Verilog-with-OOPs: Foundational Verification Principles

This repository contains a comprehensive collection of **SystemVerilog** code examples focusing exclusively on **Object-Oriented Programming (OOP) principles** and the creation of essential, modular verification components.

This project demonstrates how to build a robust, scalable testbench environment using pure SystemVerilog classes and constructs, **without relying on the UVM framework.**

All examples are self-contained and include the SystemVerilog code, a brief description, and the corresponding simulation output for immediate reference in the single file, **`source.sv`**.

---

## ðŸš€ Key Topics and Concepts

The examples are logically grouped to showcase fundamental OOP theory applied directly to hardware verification needs.

### 1. Core SystemVerilog OOP Fundamentals

| Topic | Description | Implemented Examples |
| :--- | :--- | :--- |
| **Classes & Objects** | Basic class structure (`class vlsi`), object handles, and object creation (`v = new()`). | Simple `vlsi` class with `string` and `int` members. |
| **Custom Constructors** | Defining user-defined constructors and using the **`this`** keyword for member initialization. | Constructor overloads and initialization using **`this.member = member`** to resolve name conflicts. |
| **Access Control** | Demonstrations of **`local`** (restricted to the class) and **`protected`** (restricted to the class and its derivatives) variable scoping. | Examples contrasting `local`, `protected`, and public (default) access visibility. |
| **Inheritance** | Implementing single and multi-level class hierarchy for code extension. | Multi-level inheritance (`parent` $\rightarrow$ `child` $\rightarrow$ `child1/child2`). |
| **Method Overriding & `super`** | Overriding parent class methods in the child class and using the **`super`** keyword to explicitly call the parent's implementation, including the constructor `super.new()`. | Overriding a `display()` function and using `super.display()` to access the parent version. |
| **Polymorphism** | Runtime method resolution using the **`virtual`** keyword on methods for dynamic behavior. | A `remote` base class with derived `fan`, `ac`, and `light` classes, demonstrating dynamic method calling via a base-class array of handles. |
| **Abstract Classes** | Using **`virtual class`** to define an un-instantiable base class, and **`pure virtual function`** to enforce method implementation in all derived classes. | Examples demonstrating the compilation error for instantiating an abstract class, and enforcing method implementation using `pure virtual function`. |
| **Static Properties** | Using **`static`** class members, which are shared across all objects, and accessing them via the **Scope Resolution Operator (`::`)**. | Code contrasting non-static vs. static members when accessing them using the `Class::member` syntax. |
| **Copying Mechanisms** | Detailed examples comparing **Object Copying** (copy-by-handle), **Shallow Copy** (`new src_obj`), and **Deep Copy** (manual recursive copying) for managing memory with nested objects. | Clear demonstration of how Shallow Copy fails for nested object properties, necessitating a custom Deep Copy function. |
| **Casting** | Safe type conversion between class handles using the **`$cast`** system function/task for upcasting (derived $\rightarrow$ base) and downcasting (base $\rightarrow$ derived). | Examples of successful **Upcasting** and the runtime error generated by illegal **Downcasting**. |
| **Randomization** | Using **`rand`** variables with **`constraint`** blocks, including **`inside`**, **`dist`**, **`unique`**, **`soft`**, and **`solve before`** constraints. | Demonstrations of enabling/disabling randomization of members/classes (`rand_mode`) and constraints (`constraint_mode`). |

### 2. Modular Testbench Architecture (Generator/Driver/Mailbox)

This section demonstrates the modular, component-based approach to testbench constructionâ€”the architectural foundation for methodologies like UVMâ€”but built from scratch.

| Component Demonstrated | Design Under Test (DUT) |
| :--- | :--- |
| **Transaction Class** | Defining data packets with **`rand`** variables and **`constraint`** blocks for randomization (e.g., APB Transaction). |
| **Generator** | Creates and randomizes transaction objects, then sends them to the Driver. |
| **Driver** | Receives transaction objects via the mailbox and drives stimulus onto the virtual interface connected to the DUT. |
| **Mailbox** | Used as the standard **Inter-Process Communication (IPC)** channel between the Generator and Driver. |
| **DUT Examples** | **2-to-1 MUX**, **Adder** (4-bit), **Half Adder**, **Full Adder**, **Half Subtractor**, **Full Subtractor**, and a D Flip-Flop. |

### 3. Concurrency and Synchronization

| Topic | Description | Implemented Examples |
| :--- | :--- | :--- |
| **Concurrency Control** | Use of **`fork/join`** (wait for all), **`fork/join_any`** (wait for one), and **`fork/join_none`** (fire-and-forget) to manage parallel threads in the testbench. | Detailed simulation output shows the time difference for each `fork/join` variant. |
| **Synchronization** | Using the **`event`** construct to signal completion between procedural blocks. | Synchronization example for a basic generator/driver using an `event done` and `wait(done.triggered)`. |
| **Task Argument Passing** | Practical differences between **Pass-by-Value** (`input`) and **Pass-by-Reference** (`ref`, `const ref`) in tasks, particularly with large data structures. | Demonstrations showing `input` is for scalars/single variables (no change to original variable) and `ref`/`const ref` is for arrays and in-place modification. |
| **Interfaces & Modports** | Using **`interface`** to bundle signals and **`modport`** to define directional access (e.g., `teacher` vs. `student` access). | `college_if` example with `teacher` (output), `student` (input), and `principal` (mixed access) modports. |

### 4. Advanced Logic & Control

| Topic | Description | Implemented Examples |
| :--- | :--- | :--- |
| **Procedural Blocks** | Comparison of implicit sensitivity list usage with **`always@(a)`** and the explicit **`always_comb`**. | Example illustrating the potential synchronization issue when `always@(a)` misses variables like `b` and `c`, compared to `always_comb`. |
| **Signal Edge Detection** | Using sequential logic constructs like **`$rose`** and **`$fell`** within an `always_ff` block. | A `door_controller` DUT example for opening/closing a door on rising/falling edges of a `sensor_mat`. |
| **Conditional Assertions** | Use of **`unique if`**, **`unique0 if`**, and **`priority if`** to formally verify that combinational logic implements desired priority or exclusivity. | Examples showing how `unique if` fails if more than one condition is true, and how `priority if` executes only the first true branch. |
| **Queues** | Implementation of **LIFO** (Last-In, First-Out) and **FIFO** (First-In, First-Out) data structures using SystemVerilog dynamic queues (`intQ[$]`). | Parameterized class to switch between LIFO (`pop_back()`) and FIFO (`pop_front()`) logic. |

---

## ðŸ’¡ How to Use This Resource

This repository is designed as a direct reference and learning tool:

1.  **Code is in `source.sv`**: All complete, heavily commented examples are located within this single file.
2.  **Self-Contained Examples**: Each code snippet is complete with its testbench structure, making it easy to copy and paste into any SystemVerilog simulator (e.g., EDA Playground, QuestaSim, VCS) to observe the output directly.
3.  **Focus on Output**: The comments include the exact simulation output, allowing you to confirm correct behavior and fully grasp the underlying SystemVerilog mechanism demonstrated.

This is an ideal repository for learning and mastering the core OOP concepts that underpin all advanced SystemVerilog verification.
